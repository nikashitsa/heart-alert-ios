// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exercise_route2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// ROUTE2.BPB=PbExerciseRouteSamples2

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
///Synchronization point for location.
public struct Data_PbLocationSyncPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sync Point Latitude, value is positive on northern hemisphere
  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  /// Sync Point Longitude, value is positive on eastern hemisphere
  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
}

///
///Route samples sync point.
///
///Sync points can be inserted in the data multiple times to synchronize the sample stream
///and reconfigure the granularity and other parameters of the delta stream.
public struct Data_PbExerciseRouteSyncPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sync point index.
  /// Determines the sample index starting from which
  /// this sync info is valid.
  /// For example index = 0 is the starting sync point.
  /// index [n] refers to [n]:th index in the delta data
  var index: UInt32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  /// If exists, this sync point also synchronizes location
  var location: Data_PbLocationSyncPoint {
    get {return _location ?? Data_PbLocationSyncPoint()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  /// If exists, this sync point also synchronizes time
  /// date and time in GPS time
  var gpsDateTime: PbSystemDateTime {
    get {return _gpsDateTime ?? PbSystemDateTime()}
    set {_gpsDateTime = newValue}
  }
  /// Returns true if `gpsDateTime` has been explicitly set.
  var hasGpsDateTime: Bool {return self._gpsDateTime != nil}
  /// Clears the value of `gpsDateTime`. Subsequent reads from it will return its default value.
  mutating func clearGpsDateTime() {self._gpsDateTime = nil}

  /// If exists, this sync point also synchronizes
  /// Altitude [centimeters from sea level]
  var altitude: Int32 {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  /// Granularity of coordinate (lat,lon) deltas starting
  /// from this Sync Point [nanodegrees]
  /// Example: 100 nanodegrees granularity
  ///  Latitude:  64.9430667
  ///  Longitude: 25.4468517
  ///              0.0000001 (100 nanodegrees granularity, 7 decimals)
  /// If not defined, the default value is used starting
  /// from this point onwards.
  var coordinateGranularity: UInt32 {
    get {return _coordinateGranularity ?? 100}
    set {_coordinateGranularity = newValue}
  }
  /// Returns true if `coordinateGranularity` has been explicitly set.
  var hasCoordinateGranularity: Bool {return self._coordinateGranularity != nil}
  /// Clears the value of `coordinateGranularity`. Subsequent reads from it will return its default value.
  mutating func clearCoordinateGranularity() {self._coordinateGranularity = nil}

  /// Granularity of timestamp deltas starting from
  /// this Sync Point [milliseconds]. If not defined, the default
  /// value is used starting from this point onwards.
  var timestampGranularity: UInt32 {
    get {return _timestampGranularity ?? 1000}
    set {_timestampGranularity = newValue}
  }
  /// Returns true if `timestampGranularity` has been explicitly set.
  var hasTimestampGranularity: Bool {return self._timestampGranularity != nil}
  /// Clears the value of `timestampGranularity`. Subsequent reads from it will return its default value.
  mutating func clearTimestampGranularity() {self._timestampGranularity = nil}

  /// Granularity of altitude deltas starting from
  /// this Sync Point [millimeters]. If not defined, the default
  /// value is used starting from this point onwards.
  var altitudeGranularity: UInt32 {
    get {return _altitudeGranularity ?? 1000}
    set {_altitudeGranularity = newValue}
  }
  /// Returns true if `altitudeGranularity` has been explicitly set.
  var hasAltitudeGranularity: Bool {return self._altitudeGranularity != nil}
  /// Clears the value of `altitudeGranularity`. Subsequent reads from it will return its default value.
  mutating func clearAltitudeGranularity() {self._altitudeGranularity = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

  fileprivate var _index: UInt32? = nil
  fileprivate var _location: Data_PbLocationSyncPoint? = nil
  fileprivate var _gpsDateTime: PbSystemDateTime? = nil
  fileprivate var _altitude: Int32? = nil
  fileprivate var _coordinateGranularity: UInt32? = nil
  fileprivate var _timestampGranularity: UInt32? = nil
  fileprivate var _altitudeGranularity: UInt32? = nil
}

///
///Route samples of the exercise.
///Route is encoded in delta-format, that is, by using reference points ("Sync points")
///and number of incremental changes to those points.
///
///The data format is optimized to give as small as possible changes for each new coordinate
///so that the Google Protocol Buffers delta coding can squeeze the data as small as possible.
///
///The usage of Sync Points gives possibility and flexibility to reconfigure the stream during
///the packing if the conditions change.
///
///Real data at point x since given sync point can be calculated by:
///-----------------------------------------------------------------------------
///latitude[x]  = sync_point->latitude  +
///SUM n=0..x ((sync_point->coordinate_granularity * latitude(n))* .000000001)
///longitude[x] = sync_point->longitude +
///SUM n=0..x ((sync_point->coordinate_granularity * longitude(n))* .000000001)
///timestamp[x] = sync_point->gps_date_time +
///SUM n=0..x (sync_point->timestamp_granularity * timestamp(n))
///altitude[x]  = sync_point->altitude  +
///SUM n=0..x (sync_point->altitude_granularity * altitude(n))
///
///To get data for any arbitrary point you need to iterate with given formula over all
///previous synchronization points.
///
///For the sample indexes which have also sync points, the result values are calculated
///using the NEW sync point.
///
///Datapoints without GPS FIX are not saved. The fixless-time can be seen from the timestamps
///moving forward.
public struct Data_PbExerciseRouteSamples2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Points to which incrementally the deltas are accumulated
  var syncPoint: [Data_PbExerciseRouteSyncPoint] = []

  /// Number of satellites
  var satelliteAmount: [UInt32] = []

  /// Delta coded latitude values, in granularity-units defined in previous syncpoint,
  /// relative to previous latitude value. One value per sample index.
  /// Accuracy 7 decimals.
  var latitude: [Int64] = []

  /// Delta coded longitude values, in granularity-units defined in previous syncpoint,
  /// relative to previous longitude value. One value per sample index.
  /// Accuracy 7 decimals.
  var longitude: [Int64] = []

  /// Delta coded timestamp values, in granularity-units defined in previous syncpoint,
  /// relative to previous timestamp. One value per sample index.
  var timestamp: [Int32] = []

  /// Delta coded altitude values, in granularity-units defined in previous syncpoint,
  /// relative to previous altitude. One value per sample index, if data available.
  var altitude: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Data_PbLocationSyncPoint: @unchecked Sendable {}
extension Data_PbExerciseRouteSyncPoint: @unchecked Sendable {}
extension Data_PbExerciseRouteSamples2: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data"

extension Data_PbLocationSyncPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PbLocationSyncPoint"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  public var isInitialized: Bool {
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    return true
  }

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Data_PbLocationSyncPoint, rhs: Data_PbLocationSyncPoint) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseRouteSyncPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PbExerciseRouteSyncPoint"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "location"),
    3: .standard(proto: "gps_date_time"),
    4: .same(proto: "altitude"),
    5: .standard(proto: "coordinate_granularity"),
    6: .standard(proto: "timestamp_granularity"),
    7: .standard(proto: "altitude_granularity"),
  ]

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if let v = self._location, !v.isInitialized {return false}
    if let v = self._gpsDateTime, !v.isInitialized {return false}
    return true
  }

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gpsDateTime) }()
      case 4: try { try decoder.decodeSingularSInt32Field(value: &self._altitude) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._coordinateGranularity) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._timestampGranularity) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._altitudeGranularity) }()
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gpsDateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._altitude {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._coordinateGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timestampGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._altitudeGranularity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Data_PbExerciseRouteSyncPoint, rhs: Data_PbExerciseRouteSyncPoint) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._location != rhs._location {return false}
    if lhs._gpsDateTime != rhs._gpsDateTime {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs._coordinateGranularity != rhs._coordinateGranularity {return false}
    if lhs._timestampGranularity != rhs._timestampGranularity {return false}
    if lhs._altitudeGranularity != rhs._altitudeGranularity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseRouteSamples2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PbExerciseRouteSamples2"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sync_point"),
    2: .standard(proto: "satellite_amount"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "altitude"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.syncPoint) {return false}
    return true
  }

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.syncPoint) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.satelliteAmount) }()
      case 3: try { try decoder.decodeRepeatedSInt64Field(value: &self.latitude) }()
      case 4: try { try decoder.decodeRepeatedSInt64Field(value: &self.longitude) }()
      case 5: try { try decoder.decodeRepeatedSInt32Field(value: &self.timestamp) }()
      case 6: try { try decoder.decodeRepeatedSInt64Field(value: &self.altitude) }()
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.syncPoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.syncPoint, fieldNumber: 1)
    }
    if !self.satelliteAmount.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.satelliteAmount, fieldNumber: 2)
    }
    if !self.latitude.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.latitude, fieldNumber: 3)
    }
    if !self.longitude.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.longitude, fieldNumber: 4)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.timestamp, fieldNumber: 5)
    }
    if !self.altitude.isEmpty {
      try visitor.visitPackedSInt64Field(value: self.altitude, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Data_PbExerciseRouteSamples2, rhs: Data_PbExerciseRouteSamples2) -> Bool {
    if lhs.syncPoint != rhs.syncPoint {return false}
    if lhs.satelliteAmount != rhs.satelliteAmount {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
