// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exercise_base.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// BASE.BPB=PbExerciseBase

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Data_PbExerciseCounters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of maximal sprints
  var sprintCount: UInt32 {
    get {return _sprintCount ?? 0}
    set {_sprintCount = newValue}
  }
  /// Returns true if `sprintCount` has been explicitly set.
  var hasSprintCount: Bool {return self._sprintCount != nil}
  /// Clears the value of `sprintCount`. Subsequent reads from it will return its default value.
  mutating func clearSprintCount() {self._sprintCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sprintCount: UInt32? = nil
}

public struct Data_PbExerciseBase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// range [value should be in the past of current time]
  /// Note: This is in User's Local time, ie. the value
  /// that is shown on wrist units display.
  var start: PbLocalDateTime {
    get {return _storage._start ?? PbLocalDateTime()}
    set {_uniqueStorage()._start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return _storage._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {_uniqueStorage()._start = nil}

  /// range [00:00:00.000 - 99:59:59.999]
  /// Active duration of exercise (does not include paused times)
  var duration: PbDuration {
    get {return _storage._duration ?? PbDuration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {_uniqueStorage()._duration = nil}

  /// Selected sport for the exercise
  var sport: PbSportIdentifier {
    get {return _storage._sport ?? PbSportIdentifier()}
    set {_uniqueStorage()._sport = newValue}
  }
  /// Returns true if `sport` has been explicitly set.
  var hasSport: Bool {return _storage._sport != nil}
  /// Clears the value of `sport`. Subsequent reads from it will return its default value.
  mutating func clearSport() {_uniqueStorage()._sport = nil}

  /// Distance covered during the exercise in meters.
  /// range [0 - 9999000] m
  var distance: Float {
    get {return _storage._distance ?? 0}
    set {_uniqueStorage()._distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return _storage._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {_uniqueStorage()._distance = nil}

  /// Calories burned during the exercise.
  /// range [0 - 65535] kcal
  var calories: UInt32 {
    get {return _storage._calories ?? 0}
    set {_uniqueStorage()._calories = newValue}
  }
  /// Returns true if `calories` has been explicitly set.
  var hasCalories: Bool {return _storage._calories != nil}
  /// Clears the value of `calories`. Subsequent reads from it will return its default value.
  mutating func clearCalories() {_uniqueStorage()._calories = nil}

  /// Training load of exercise
  var trainingLoad: PbTrainingLoad {
    get {return _storage._trainingLoad ?? PbTrainingLoad()}
    set {_uniqueStorage()._trainingLoad = newValue}
  }
  /// Returns true if `trainingLoad` has been explicitly set.
  var hasTrainingLoad: Bool {return _storage._trainingLoad != nil}
  /// Clears the value of `trainingLoad`. Subsequent reads from it will return its default value.
  mutating func clearTrainingLoad() {_uniqueStorage()._trainingLoad = nil}

  /// Available sensor features during training session
  /// These are ESW internal types so validity checking is a very important thing with these
  var availableSensorFeatures: [PbFeatureType] {
    get {return _storage._availableSensorFeatures}
    set {_uniqueStorage()._availableSensorFeatures = newValue}
  }

  /// Running Index
  var runningIndex: PbRunningIndex {
    get {return _storage._runningIndex ?? PbRunningIndex()}
    set {_uniqueStorage()._runningIndex = newValue}
  }
  /// Returns true if `runningIndex` has been explicitly set.
  var hasRunningIndex: Bool {return _storage._runningIndex != nil}
  /// Clears the value of `runningIndex`. Subsequent reads from it will return its default value.
  mutating func clearRunningIndex() {_uniqueStorage()._runningIndex = nil}

  /// Cumulative ascent
  /// range [0 - 99000] m
  var ascent: Float {
    get {return _storage._ascent ?? 0}
    set {_uniqueStorage()._ascent = newValue}
  }
  /// Returns true if `ascent` has been explicitly set.
  var hasAscent: Bool {return _storage._ascent != nil}
  /// Clears the value of `ascent`. Subsequent reads from it will return its default value.
  mutating func clearAscent() {_uniqueStorage()._ascent = nil}

  /// Cumulative descent
  /// range [0 - 99000] m
  var descent: Float {
    get {return _storage._descent ?? 0}
    set {_uniqueStorage()._descent = newValue}
  }
  /// Returns true if `descent` has been explicitly set.
  var hasDescent: Bool {return _storage._descent != nil}
  /// Clears the value of `descent`. Subsequent reads from it will return its default value.
  mutating func clearDescent() {_uniqueStorage()._descent = nil}

  /// Latitude where the exercise started
  var latitude: Double {
    get {return _storage._latitude ?? 0}
    set {_uniqueStorage()._latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return _storage._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {_uniqueStorage()._latitude = nil}

  /// Longitude where the exercise started
  var longitude: Double {
    get {return _storage._longitude ?? 0}
    set {_uniqueStorage()._longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return _storage._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {_uniqueStorage()._longitude = nil}

  /// Place of the exercise
  var place: String {
    get {return _storage._place ?? String()}
    set {_uniqueStorage()._place = newValue}
  }
  /// Returns true if `place` has been explicitly set.
  var hasPlace: Bool {return _storage._place != nil}
  /// Clears the value of `place`. Subsequent reads from it will return its default value.
  mutating func clearPlace() {_uniqueStorage()._place = nil}

  /// Countable data of exercise
  var exerciseCounters: Data_PbExerciseCounters {
    get {return _storage._exerciseCounters ?? Data_PbExerciseCounters()}
    set {_uniqueStorage()._exerciseCounters = newValue}
  }
  /// Returns true if `exerciseCounters` has been explicitly set.
  var hasExerciseCounters: Bool {return _storage._exerciseCounters != nil}
  /// Clears the value of `exerciseCounters`. Subsequent reads from it will return its default value.
  mutating func clearExerciseCounters() {_uniqueStorage()._exerciseCounters = nil}

  /// Calibration offset calculated from motion sensor and gps average speed
  var obsoleteSpeedCalibrationOffset: Float {
    get {return _storage._obsoleteSpeedCalibrationOffset ?? 0}
    set {_uniqueStorage()._obsoleteSpeedCalibrationOffset = newValue}
  }
  /// Returns true if `obsoleteSpeedCalibrationOffset` has been explicitly set.
  var hasObsoleteSpeedCalibrationOffset: Bool {return _storage._obsoleteSpeedCalibrationOffset != nil}
  /// Clears the value of `obsoleteSpeedCalibrationOffset`. Subsequent reads from it will return its default value.
  mutating func clearObsoleteSpeedCalibrationOffset() {_uniqueStorage()._obsoleteSpeedCalibrationOffset = nil}

  /// Walking distance covered during the exercise in meters.
  /// range [0 - 9999000] m
  var walkingDistance: Float {
    get {return _storage._walkingDistance ?? 0}
    set {_uniqueStorage()._walkingDistance = newValue}
  }
  /// Returns true if `walkingDistance` has been explicitly set.
  var hasWalkingDistance: Bool {return _storage._walkingDistance != nil}
  /// Clears the value of `walkingDistance`. Subsequent reads from it will return its default value.
  mutating func clearWalkingDistance() {_uniqueStorage()._walkingDistance = nil}

  /// range [00:00:00.000 - 99:59:59.999]
  var walkingDuration: PbDuration {
    get {return _storage._walkingDuration ?? PbDuration()}
    set {_uniqueStorage()._walkingDuration = newValue}
  }
  /// Returns true if `walkingDuration` has been explicitly set.
  var hasWalkingDuration: Bool {return _storage._walkingDuration != nil}
  /// Clears the value of `walkingDuration`. Subsequent reads from it will return its default value.
  mutating func clearWalkingDuration() {_uniqueStorage()._walkingDuration = nil}

  ///Accumulated torque from cycling power sensor.
  ///Unit is in newton metres with a resolution of 1/32.
  var accumulatedTorque: UInt32 {
    get {return _storage._accumulatedTorque ?? 0}
    set {_uniqueStorage()._accumulatedTorque = newValue}
  }
  /// Returns true if `accumulatedTorque` has been explicitly set.
  var hasAccumulatedTorque: Bool {return _storage._accumulatedTorque != nil}
  /// Clears the value of `accumulatedTorque`. Subsequent reads from it will return its default value.
  mutating func clearAccumulatedTorque() {_uniqueStorage()._accumulatedTorque = nil}

  ///Accumulated energy from cycling power sensor
  /// range [0 - 65535] kcal
  var cyclingPowerEnergy: UInt32 {
    get {return _storage._cyclingPowerEnergy ?? 0}
    set {_uniqueStorage()._cyclingPowerEnergy = newValue}
  }
  /// Returns true if `cyclingPowerEnergy` has been explicitly set.
  var hasCyclingPowerEnergy: Bool {return _storage._cyclingPowerEnergy != nil}
  /// Clears the value of `cyclingPowerEnergy`. Subsequent reads from it will return its default value.
  mutating func clearCyclingPowerEnergy() {_uniqueStorage()._cyclingPowerEnergy = nil}

  /// Calibration offset for motion sensor based calculation.
  var sensorCalibrationOffset: [PbSensorCalibrationOffset] {
    get {return _storage._sensorCalibrationOffset}
    set {_uniqueStorage()._sensorCalibrationOffset = newValue}
  }

  /// The location of the device in the exercise.
  var deviceLocation: PbDeviceLocation {
    get {return _storage._deviceLocation ?? .deviceLocationUndefined}
    set {_uniqueStorage()._deviceLocation = newValue}
  }
  /// Returns true if `deviceLocation` has been explicitly set.
  var hasDeviceLocation: Bool {return _storage._deviceLocation != nil}
  /// Clears the value of `deviceLocation`. Subsequent reads from it will return its default value.
  mutating func clearDeviceLocation() {_uniqueStorage()._deviceLocation = nil}

  /// The source device of power samples in the exercise.
  var powerSampleSourceDevice: [PbSampleSourceDevice] {
    get {return _storage._powerSampleSourceDevice}
    set {_uniqueStorage()._powerSampleSourceDevice = newValue}
  }

  /// Cardio load of the exercise
  var cardioLoad: PbCardioLoad {
    get {return _storage._cardioLoad ?? PbCardioLoad()}
    set {_uniqueStorage()._cardioLoad = newValue}
  }
  /// Returns true if `cardioLoad` has been explicitly set.
  var hasCardioLoad: Bool {return _storage._cardioLoad != nil}
  /// Clears the value of `cardioLoad`. Subsequent reads from it will return its default value.
  mutating func clearCardioLoad() {_uniqueStorage()._cardioLoad = nil}

  /// "Hardness": comparison of cardio load to 90 day average [ 1...5 = very low...very high ]
  var cardioLoadInterpretation: UInt32 {
    get {return _storage._cardioLoadInterpretation ?? 0}
    set {_uniqueStorage()._cardioLoadInterpretation = newValue}
  }
  /// Returns true if `cardioLoadInterpretation` has been explicitly set.
  var hasCardioLoadInterpretation: Bool {return _storage._cardioLoadInterpretation != nil}
  /// Clears the value of `cardioLoadInterpretation`. Subsequent reads from it will return its default value.
  mutating func clearCardioLoadInterpretation() {_uniqueStorage()._cardioLoadInterpretation = nil}

  /// Perceived load of the exercise
  var perceivedLoad: PbPerceivedLoad {
    get {return _storage._perceivedLoad ?? PbPerceivedLoad()}
    set {_uniqueStorage()._perceivedLoad = newValue}
  }
  /// Returns true if `perceivedLoad` has been explicitly set.
  var hasPerceivedLoad: Bool {return _storage._perceivedLoad != nil}
  /// Clears the value of `perceivedLoad`. Subsequent reads from it will return its default value.
  mutating func clearPerceivedLoad() {_uniqueStorage()._perceivedLoad = nil}

  /// "Hardness": comparison of perceived load to 90 day average [ 1...5 = very low...very high ]
  var perceivedLoadInterpretation: UInt32 {
    get {return _storage._perceivedLoadInterpretation ?? 0}
    set {_uniqueStorage()._perceivedLoadInterpretation = newValue}
  }
  /// Returns true if `perceivedLoadInterpretation` has been explicitly set.
  var hasPerceivedLoadInterpretation: Bool {return _storage._perceivedLoadInterpretation != nil}
  /// Clears the value of `perceivedLoadInterpretation`. Subsequent reads from it will return its default value.
  mutating func clearPerceivedLoadInterpretation() {_uniqueStorage()._perceivedLoadInterpretation = nil}

  /// Muscle load of the exercise, calculated from running or cycling power (kJ)
  var muscleLoad: Float {
    get {return _storage._muscleLoad ?? 0}
    set {_uniqueStorage()._muscleLoad = newValue}
  }
  /// Returns true if `muscleLoad` has been explicitly set.
  var hasMuscleLoad: Bool {return _storage._muscleLoad != nil}
  /// Clears the value of `muscleLoad`. Subsequent reads from it will return its default value.
  mutating func clearMuscleLoad() {_uniqueStorage()._muscleLoad = nil}

  /// "Hardness": comparison of cardio load to 90 day average [ 1...5 = very low...very high ]
  var muscleLoadInterpretation: UInt32 {
    get {return _storage._muscleLoadInterpretation ?? 0}
    set {_uniqueStorage()._muscleLoadInterpretation = newValue}
  }
  /// Returns true if `muscleLoadInterpretation` has been explicitly set.
  var hasMuscleLoadInterpretation: Bool {return _storage._muscleLoadInterpretation != nil}
  /// Clears the value of `muscleLoadInterpretation`. Subsequent reads from it will return its default value.
  mutating func clearMuscleLoadInterpretation() {_uniqueStorage()._muscleLoadInterpretation = nil}

  /// Timestamp of modification of the component fields (especially perceived_load). Needed in case of syncing between several devices.
  /// Currently perceived_load is the only field that can be modified afterwards but in future case of several modifiable fields a separate timestamp for
  /// each needs to be considered.
  var lastModified: PbSystemDateTime {
    get {return _storage._lastModified ?? PbSystemDateTime()}
    set {_uniqueStorage()._lastModified = newValue}
  }
  /// Returns true if `lastModified` has been explicitly set.
  var hasLastModified: Bool {return _storage._lastModified != nil}
  /// Clears the value of `lastModified`. Subsequent reads from it will return its default value.
  mutating func clearLastModified() {_uniqueStorage()._lastModified = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Data_PbExerciseCounters: @unchecked Sendable {}
extension Data_PbExerciseBase: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data"

extension Data_PbExerciseCounters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbExerciseCounters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sprint_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._sprintCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sprintCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_PbExerciseCounters, rhs: Data_PbExerciseCounters) -> Bool {
    if lhs._sprintCount != rhs._sprintCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_PbExerciseBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PbExerciseBase"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "duration"),
    3: .same(proto: "sport"),
    4: .same(proto: "distance"),
    5: .same(proto: "calories"),
    6: .standard(proto: "training_load"),
    7: .standard(proto: "available_sensor_features"),
    9: .standard(proto: "running_index"),
    10: .same(proto: "ascent"),
    11: .same(proto: "descent"),
    12: .same(proto: "latitude"),
    13: .same(proto: "longitude"),
    14: .same(proto: "place"),
    16: .standard(proto: "exercise_counters"),
    17: .standard(proto: "OBSOLETE_speed_calibration_offset"),
    18: .standard(proto: "walking_distance"),
    19: .standard(proto: "walking_duration"),
    20: .standard(proto: "accumulated_torque"),
    21: .standard(proto: "cycling_power_energy"),
    22: .standard(proto: "sensor_calibration_offset"),
    23: .standard(proto: "device_location"),
    24: .standard(proto: "power_sample_source_device"),
    25: .standard(proto: "cardio_load"),
    26: .standard(proto: "cardio_load_interpretation"),
    27: .standard(proto: "perceived_load"),
    28: .standard(proto: "perceived_load_interpretation"),
    29: .standard(proto: "muscle_load"),
    30: .standard(proto: "muscle_load_interpretation"),
    100: .standard(proto: "last_modified"),
  ]

  fileprivate class _StorageClass {
    var _start: PbLocalDateTime? = nil
    var _duration: PbDuration? = nil
    var _sport: PbSportIdentifier? = nil
    var _distance: Float? = nil
    var _calories: UInt32? = nil
    var _trainingLoad: PbTrainingLoad? = nil
    var _availableSensorFeatures: [PbFeatureType] = []
    var _runningIndex: PbRunningIndex? = nil
    var _ascent: Float? = nil
    var _descent: Float? = nil
    var _latitude: Double? = nil
    var _longitude: Double? = nil
    var _place: String? = nil
    var _exerciseCounters: Data_PbExerciseCounters? = nil
    var _obsoleteSpeedCalibrationOffset: Float? = nil
    var _walkingDistance: Float? = nil
    var _walkingDuration: PbDuration? = nil
    var _accumulatedTorque: UInt32? = nil
    var _cyclingPowerEnergy: UInt32? = nil
    var _sensorCalibrationOffset: [PbSensorCalibrationOffset] = []
    var _deviceLocation: PbDeviceLocation? = nil
    var _powerSampleSourceDevice: [PbSampleSourceDevice] = []
    var _cardioLoad: PbCardioLoad? = nil
    var _cardioLoadInterpretation: UInt32? = nil
    var _perceivedLoad: PbPerceivedLoad? = nil
    var _perceivedLoadInterpretation: UInt32? = nil
    var _muscleLoad: Float? = nil
    var _muscleLoadInterpretation: UInt32? = nil
    var _lastModified: PbSystemDateTime? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _start = source._start
      _duration = source._duration
      _sport = source._sport
      _distance = source._distance
      _calories = source._calories
      _trainingLoad = source._trainingLoad
      _availableSensorFeatures = source._availableSensorFeatures
      _runningIndex = source._runningIndex
      _ascent = source._ascent
      _descent = source._descent
      _latitude = source._latitude
      _longitude = source._longitude
      _place = source._place
      _exerciseCounters = source._exerciseCounters
      _obsoleteSpeedCalibrationOffset = source._obsoleteSpeedCalibrationOffset
      _walkingDistance = source._walkingDistance
      _walkingDuration = source._walkingDuration
      _accumulatedTorque = source._accumulatedTorque
      _cyclingPowerEnergy = source._cyclingPowerEnergy
      _sensorCalibrationOffset = source._sensorCalibrationOffset
      _deviceLocation = source._deviceLocation
      _powerSampleSourceDevice = source._powerSampleSourceDevice
      _cardioLoad = source._cardioLoad
      _cardioLoadInterpretation = source._cardioLoadInterpretation
      _perceivedLoad = source._perceivedLoad
      _perceivedLoadInterpretation = source._perceivedLoadInterpretation
      _muscleLoad = source._muscleLoad
      _muscleLoadInterpretation = source._muscleLoadInterpretation
      _lastModified = source._lastModified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._start == nil {return false}
      if _storage._duration == nil {return false}
      if _storage._sport == nil {return false}
      if let v = _storage._start, !v.isInitialized {return false}
      if let v = _storage._sport, !v.isInitialized {return false}
      if let v = _storage._trainingLoad, !v.isInitialized {return false}
      if let v = _storage._runningIndex, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sensorCalibrationOffset) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._powerSampleSourceDevice) {return false}
      if let v = _storage._cardioLoad, !v.isInitialized {return false}
      if let v = _storage._perceivedLoad, !v.isInitialized {return false}
      if let v = _storage._lastModified, !v.isInitialized {return false}
      return true
    }
  }

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._start) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._duration) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sport) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._distance) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._calories) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._trainingLoad) }()
        case 7: try { try decoder.decodeRepeatedEnumField(value: &_storage._availableSensorFeatures) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._runningIndex) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._ascent) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._descent) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._latitude) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._longitude) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._place) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._exerciseCounters) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._obsoleteSpeedCalibrationOffset) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._walkingDistance) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._walkingDuration) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._accumulatedTorque) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._cyclingPowerEnergy) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._sensorCalibrationOffset) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._deviceLocation) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._powerSampleSourceDevice) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._cardioLoad) }()
        case 26: try { try decoder.decodeSingularUInt32Field(value: &_storage._cardioLoadInterpretation) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._perceivedLoad) }()
        case 28: try { try decoder.decodeSingularUInt32Field(value: &_storage._perceivedLoadInterpretation) }()
        case 29: try { try decoder.decodeSingularFloatField(value: &_storage._muscleLoad) }()
        case 30: try { try decoder.decodeSingularUInt32Field(value: &_storage._muscleLoadInterpretation) }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._lastModified) }()
        default: break
        }
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._start {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sport {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._distance {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._calories {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._trainingLoad {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._availableSensorFeatures.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._availableSensorFeatures, fieldNumber: 7)
      }
      try { if let v = _storage._runningIndex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._ascent {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._descent {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._latitude {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._longitude {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._place {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._exerciseCounters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._obsoleteSpeedCalibrationOffset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._walkingDistance {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._walkingDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._accumulatedTorque {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._cyclingPowerEnergy {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 21)
      } }()
      if !_storage._sensorCalibrationOffset.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sensorCalibrationOffset, fieldNumber: 22)
      }
      try { if let v = _storage._deviceLocation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 23)
      } }()
      if !_storage._powerSampleSourceDevice.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._powerSampleSourceDevice, fieldNumber: 24)
      }
      try { if let v = _storage._cardioLoad {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._cardioLoadInterpretation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._perceivedLoad {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._perceivedLoadInterpretation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._muscleLoad {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._muscleLoadInterpretation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._lastModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: Data_PbExerciseBase, rhs: Data_PbExerciseBase) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._start != rhs_storage._start {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._sport != rhs_storage._sport {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._calories != rhs_storage._calories {return false}
        if _storage._trainingLoad != rhs_storage._trainingLoad {return false}
        if _storage._availableSensorFeatures != rhs_storage._availableSensorFeatures {return false}
        if _storage._runningIndex != rhs_storage._runningIndex {return false}
        if _storage._ascent != rhs_storage._ascent {return false}
        if _storage._descent != rhs_storage._descent {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._place != rhs_storage._place {return false}
        if _storage._exerciseCounters != rhs_storage._exerciseCounters {return false}
        if _storage._obsoleteSpeedCalibrationOffset != rhs_storage._obsoleteSpeedCalibrationOffset {return false}
        if _storage._walkingDistance != rhs_storage._walkingDistance {return false}
        if _storage._walkingDuration != rhs_storage._walkingDuration {return false}
        if _storage._accumulatedTorque != rhs_storage._accumulatedTorque {return false}
        if _storage._cyclingPowerEnergy != rhs_storage._cyclingPowerEnergy {return false}
        if _storage._sensorCalibrationOffset != rhs_storage._sensorCalibrationOffset {return false}
        if _storage._deviceLocation != rhs_storage._deviceLocation {return false}
        if _storage._powerSampleSourceDevice != rhs_storage._powerSampleSourceDevice {return false}
        if _storage._cardioLoad != rhs_storage._cardioLoad {return false}
        if _storage._cardioLoadInterpretation != rhs_storage._cardioLoadInterpretation {return false}
        if _storage._perceivedLoad != rhs_storage._perceivedLoad {return false}
        if _storage._perceivedLoadInterpretation != rhs_storage._perceivedLoadInterpretation {return false}
        if _storage._muscleLoad != rhs_storage._muscleLoad {return false}
        if _storage._muscleLoadInterpretation != rhs_storage._muscleLoadInterpretation {return false}
        if _storage._lastModified != rhs_storage._lastModified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
